##前端知识点总结归纳
---

### Array.forEach(value,index,obj)
第一个参数就是正在遍历的元素，第二个参数是索引，第三个就是在遍历的数组
只在ie8以上的浏览器支持
### Array.from(类数组)
用来将一个类数组如（NodeList）转化成真正的数组,结果返回一个新数组
### arr.find()
返回数组中第一个满足条件的数组
### arr.flat()
数组扁平化：将多维数组转化为一维数组，要提取多少层传多少层参数
Infinity提取无限层

### BFC的作用（块级格式化上下文）
解决父级元素高度坍塌问题
解决垂直方向上margin重叠问题

两栏自适应布局

创建方式
```
根元素（<html>）
浮动元素（元素的 float 不是 none）
绝对定位元素（元素的 position 为 absolute 或 fixed）
行内块元素（元素的 display 为 inline-block）
表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）
表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）
overflow 值不为 visible 的块元素
display 值为 flow-root 的元素
```
###  DOCTYPE
对 HTML 文件来说，浏览器使用文件开头的 DOCTYPE 来决定用怪异模式处理或标准模式处理。
### localstorage sessionstorage cookie的区别和用法
生命周期：
Cookie可以设置失效时间，如果在浏览器端生成的cookie默认是关闭浏览器后失效。
LocalStorage除非设置失效时间，否则永久保存
SessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除
 
数据大小:
cookie通常为4KB,sessionstorage与localstorage一般为5MB,并且cooike的原生API不如storage友好，需要手动封装函数

通信方面：
cookie:每次都会携带在http头中,如果cookie保存太多会带来性能问题
sessionstorage与localstorage:在浏览器中保存，不参与和服务器之间的通信,都受到同源策略的限制
### Cookie和session的区别


1.Cookie存在浏览器中，Session存在浏览器端

2.Cookie大小不超过4kb,多数浏览器限制一个站点保存50个cookie，而session原则上没有限制

3.session运行依赖sessionID，而sessionID一般存在cookie中，如果浏览器禁用了cookie，session也会失效，但是可以通过在url中传输sessionID的方式去实现

4.session相对于cookie更加的安全，因为可以轻松获取到cookie的值，所以可以将重要的值放在session中，其他信息保存在cookie中

5.当访问增多的时候，session会给服务器带来较大的负担，所以应该适当的使用cookie

### JS中的数据类型（8种）
##### 基本数据类型(nnussbb)

Number Null Undefined String Symbol Booleab BigInt
##### 对象
Object

### 懒加载

定义：一个页面如果拥有多张的图片的话，一次性的将所有图片全部加载出来会会影响性能，所用懒加载当滚动到指定的区域在进行图片的加载，这样提高了服务器的性能的同时也减轻了服务器的压力
思路：首先获取到img的dom节点，定义一个函数用来获取图片的offSetTop(获取图片距离顶部的距离)，之后遍历每个图片，将他们用load函数封装后，遍历里面的图片然后用getAttribute方法赋值给src属性最后在window.onload=window.onscroll = function()调用这个函数

### 页面reflow和layout
如果创建多个dom元素可以使用DocumentFragment一次性创建到其中在加载到浏览器中，以此来减少reflow
重排(reflow)必定会引发重绘(repaint)，但重绘不一定会引发重排。
重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）
重绘重排的代价：耗时，导致浏览器卡慢。

### 浏览器访问网站的过程
1.地址栏输入url
2.浏览器通过输入的url构建请求报文
3.浏览器发起dns解析请求，将域名转化为ip地址
4.找到ip后将构建的报文发给服务器
5.服务器收到报文后，要解析发过来的报文
6.解析完后服务器知道用户这次提交的是什么数据，然后对用户请求的数据进行处理，将处理的结果封装成http响应报文
7.将响应报文发送给浏览器
8.浏览器拿到响应报文后对其进行解析
9.浏览器解析html页面并进行展示，如果遇到新的资源需要再次发出请求
10.浏览器展示出最终的界面

### http请求报文和响应报文格式
requests
  + 包含请求行
  + 请求报文头
  + 请求报文体
 
response
  + 请求报文行
  + 请求报文头
  + 请求报文体

### 常见http请求状态码
100-199：请求正在处理
200-299：请求正常处理完毕
300-399：资源重定向
400-499：客户端错误
500-599：服务端错误

| 状态码 | 说明                                                                 |
| ------ | -------------------------------------------------------------------- |
| 100    | 请求者继续提出请求 服务器已经收到一部分 正在等待其余部分             |
| 101    | 请求者要求服务器切换协议 服务器确认并准备切换                        |
| 200    | 服务器成功处理了请求                                                 |
| 201    | 服务器请求成功并创建了新的资源                                       |
| 202    | 服务器已接受请求但是尚未处理                                         |
| 300    | 服务器根据请求者的user agent提供一项操作或者提供操作列表给请求者请求 |
| 301    | 网页已经永久移动到新的位置                                           |
| 302    | 临时移动                                                             |
| 304    | 自上次请求网页以来服务器资源未更新                                   |
| 400    | Bad Request 客户端请求语法错误，不能被服务器理解                     |
| 403    | Forbidden服务器收到请求但是拒绝执行                                  |
| 404    | Not Found请求资源不存在                                              |
| 500    | 服务器内部错误 无法完成请求                                          |
| 503    | 服务器目前无法使用                                                   |
| 504    | 网关超时                                                             |

### http1和http2的区别
http1通过文本形式传输 http2通过二进制进行传输
http2支持多路复用  http2采用头部压缩
http2支持在未经客户端允许的情况下主动向客户端推送内容

### readystate的5个状态
0 表示open()方法未被调用
1 表示send()方法未被调

2 表示send()方法已经执行，并且头信息和状态码已经收到
3 表示正在接受服务器传来的body部分数据
4 表示服务器数据接收完成

### flex属性
+ flex-direction
  - row 主轴为水平方向
  - column 主轴为垂直方向
+ flex-wrap
  - nowrap 不换行
  - wrap 换行
+ justify-content （水平方向）
  - center 居中
  - space-between 俩端对齐，间隔相等
  - space-around 距边界俩侧间隔相等
+ align-items （单轴垂直方向）
  - center 单轴垂直方向对齐
+ align-content （多轴垂直方向）
  - center 多轴垂直方向对齐

### css伪类

### H5新增标签
+ section 	定义文档中的一个章节。
+ nav 定义只包含导航链接的章节。
+ article 定义可以独立于内容其余部分的完整独立内容块。
+ aside 定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。
+ header 定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。
+ footer 定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。
+ main 定义文档中主要或重要的内容。

### 常见块级元素和行内元素
+ 块级元素
  > h1~6 div hr p pre table output article aside audio canvas dd dl ul ol form footer header 
+ 行内元素
  > b, big, i, small, tt,abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var,a, bdo, br, img, map, object, q, script, span, sub, sup,button, input, label, select, textarea

### 浅拷贝和深拷贝
在js中如果拷贝对象是基本类型，那么会拷贝基本类型的值，如果是引用类型，拷贝的是内存地址，因为如果一个对象的改变这个地址，会影响到另一个对象
总而言之，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
浅拷贝
```javascript
functionclone(target)
{
  functionclone(target){
    letcloneTarget={};
    for(constkeyintarget){
        cloneTarget[key]=target[key];
      }returncloneTarget;
    };

};
```

深拷贝
```javascript
functionclone(target)
{
  if(typeof target==='object'){
    let cloneTarget=Array.isArray(target)?[]:{};
    for(const key in target){
      cloneTarget[key]=clone(target[key]);
      }
      returncloneTarget;
      }
      else{returntarget;}
};
```
#### 手动实现intance of
```javascript
//简单的说就是判断实例对象是否在构造函数的原型对象上
// 手动实现一个
var ins = function(left,right){
    leftValue = left.__proto__;
    rightValue = right.prototype;
    while(true){
        if(leftValue===null){
            return false
        }
        if(leftValue===rightValue){
            return true
        }
        rightValue = rightValue.__proto__;
    }
}
```
#### 实现垂直水平居中
```css
div.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}

div.parent {
    position: relative; 
}
div.child {
    position: absolute; 
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
}
/* 或 */
div.child {
    width: 50px;
    height: 10px;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

div.parent {
    display: grid;
}
div.child {
    justify-self: center;
    align-self: center;
}

div.parent {
display: table;
}
div.child {
display: table-cell
vertical-align: middle;
text-align: center;
}

```
#### 捕捉，冒泡与委托
适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。
执行顺序：捕捉--》目标--》冒泡
event.stopPropagation()阻止事件的传递行为.
event.preventDefault();阻止默认行为，比如阻止a的href

优点：
1.减少事件注册，节省内存。例如上面代码，只指定 父元素的处理程序，即可管理所有所有子元素的“click”事件；
2.简化了dom节点更新时，相应事件的更新

缺点：
1.利用事件冒泡的原理，不支持不冒泡的事件；
2.层级过多，冒泡过程中，可能会被某层阻止掉；
3. 理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在ol上代理li，而不是在document上代理li。
4. 把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。

#### css3新特性
背景，支持RGBA透明度，一次多背景图
支持媒体查询
支持阴影，渐变，
支持边框图片，border-image: url(border.png) 30 30 round
支持transform位移系列
支持过渡效果transition
支持自定义字体
引入flex/grid布局
引入多种选择器

#### 继承的几种方式
1.原型链继承
2.构造函数继承
3.组合继承
4.原型式继承
5.寄生式继承
6.寄生组合
7.class继承

#### 浏览器整体的渲染过程：

+ 处理 HTML 并构建 DOM 树。
+ 处理 CSS 构建 CSSOM 树。
+ 将 DOM 与 CSSOM 合并成一个渲染树。
+ 根据渲染树来布局，计算每个节点的位置。
+ 调用 GPU 绘制，合成图层，显示在屏幕上。

#### 减少重绘和回流的细节：
1）使用 translate 替代 top
2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
3）尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
4）动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  Load 和 DOMContentLoaded 区别。Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

### 缓存
协商缓存：请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。

强缓存：cache-control的值不为，no-store    no-cahche

### get post
get是明文传输，post是放在请求体中
get用来获取数据，post用来提交数据
get请求会保存在浏览器历史记录或日志中,post不会
GET请求URL的编码格式采用的是ASCII编码，而POST支持多种编码方式。
传送长度：get参数有长度限制（受限于url长度），而post无限制
GET产生一个TCP数据包；POST产生两个TCP数据包

### 三次握手四次挥手
```
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k）

    即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，

    此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据.
_____________________________________________________________________________
第一次挥手:客户端A发送一个FIN.用来关闭客户A到服务器B的数据传送

第二次挥手:服务器B收到这个FIN. 它发回一个ACK，确认序号为收到的序号+1。和SYN一样，

    一个FIN将占用一个序号

第三次挥手:服务器B关闭与客户端A的连接，发送一个FIN给客户端A

第四次挥手:客户端A发回ACK报文确认，并将确认序号设置为序号加1
```